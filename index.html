<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover,user-scalable=no" />
  <meta name="theme-color" content="#0b1020" />
  <title>FLIP DODGE ‚Äî One Tap Arcade</title>
  <style>
    :root{
      --bg0:#070a14; --bg1:#0b1020;
      --glass: rgba(255,255,255,.10);
      --stroke: rgba(255,255,255,.14);
      --txt: rgba(255,255,255,.92);
      --muted: rgba(255,255,255,.65);
      --good:#7CFFB2; --warn:#FFD27C; --bad:#FF5A7A;
      --shadow: rgba(0,0,0,.40);
    }
    html,body{margin:0;height:100%;overflow:hidden;background:
      radial-gradient(1100px 700px at 20% 10%, rgba(120,140,255,.22), transparent 60%),
      radial-gradient(900px 600px at 80% 25%, rgba(255,120,220,.18), transparent 55%),
      linear-gradient(180deg,var(--bg1),var(--bg0));
      color:var(--txt); font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;
      -webkit-tap-highlight-color:transparent; touch-action:manipulation; user-select:none;
    }
    canvas{position:fixed;inset:0;width:100vw;height:100vh;display:block}
    #hud{
      position:fixed; left:0; right:0; top:0;
      padding:max(12px,env(safe-area-inset-top)) 12px 0;
      display:flex; justify-content:space-between; gap:10px;
      pointer-events:none;
    }
    .pill{
      pointer-events:auto;
      display:flex; align-items:center; gap:10px;
      padding:10px 12px; border-radius:999px;
      background:linear-gradient(180deg, rgba(255,255,255,.12), rgba(255,255,255,.07));
      border:1px solid var(--stroke);
      box-shadow:0 16px 50px var(--shadow);
      backdrop-filter: blur(10px);
      font-weight:800; letter-spacing:.2px;
    }
    .pill small{color:var(--muted); font-weight:700}
    .btn{
      pointer-events:auto;
      border:1px solid var(--stroke);
      background:linear-gradient(180deg, rgba(255,255,255,.14), rgba(255,255,255,.08));
      border-radius:999px; padding:10px 12px;
      box-shadow:0 16px 50px var(--shadow);
      color:var(--txt); font-weight:900;
    }
    .btn:active{transform:scale(.98)}
    #screen{
      position:fixed; inset:0; display:flex; align-items:center; justify-content:center;
      padding:max(16px,env(safe-area-inset-top)) 16px max(16px,env(safe-area-inset-bottom));
      background: radial-gradient(900px 700px at 50% 40%, rgba(0,0,0,.20), rgba(0,0,0,.45));
    }
    .card{
      width:min(520px, 94vw);
      padding:18px;
      border-radius:24px;
      background:linear-gradient(180deg, rgba(255,255,255,.12), rgba(255,255,255,.06));
      border:1px solid var(--stroke);
      box-shadow:0 22px 80px rgba(0,0,0,.50);
      backdrop-filter: blur(14px);
    }
    h1{margin:0; font-size:clamp(26px, 6vw, 36px); letter-spacing:.3px}
    .sub{margin-top:6px; color:var(--muted); font-weight:700; line-height:1.3}
    .grid{display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-top:14px}
    .box{
      border-radius:18px; padding:12px;
      background: rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.10);
    }
    .k{color:var(--muted); font-weight:800; font-size:12px; letter-spacing:.3px; text-transform:uppercase}
    .v{margin-top:4px; font-weight:950; font-size:18px}
    .row{display:flex; gap:10px; flex-wrap:wrap; margin-top:14px; justify-content:space-between}
    .row .btn{flex:1 1 160px}
    #hint{
      position:fixed; left:50%; transform:translateX(-50%);
      bottom: calc(max(14px, env(safe-area-inset-bottom)) + 10px);
      padding:10px 12px; border-radius:999px;
      background: rgba(20,25,45,.65);
      border:1px solid rgba(255,255,255,.12);
      color:var(--muted); font-weight:800;
      backdrop-filter: blur(10px);
      pointer-events:none;
      opacity:0; transition:opacity .25s ease;
    }
    #hint.show{opacity:1}
  </style>
</head>
<body>
<canvas id="c"></canvas>

<div id="hud">
  <div class="pill"><span id="score">0</span> <small id="best">Best: 0</small></div>
  <div style="display:flex; gap:10px;">
    <div class="pill"><span id="coins">0</span> <small>Stars</small></div>
    <button class="btn" id="pause">‚è∏Ô∏è</button>
  </div>
</div>

<div id="hint">Tippe irgendwo: <b>Seite wechseln</b> ‚Ä¢ Sammel ‚≠ê ‚Ä¢ Powerups: üõ°Ô∏è ‚è≥</div>

<div id="screen">
  <div class="card">
    <h1>FLIP DODGE</h1>
    <div class="sub">Ultra-einfach: <b>ein Tap</b> ‚Üí du wechselst die Seite. Weiche Hindernissen aus & sammle ‚≠ê.</div>
    <div class="grid">
      <div class="box"><div class="k">Best Score</div><div class="v" id="mBest">0</div></div>
      <div class="box"><div class="k">Stars</div><div class="v" id="mCoins">0</div></div>
    </div>
    <div class="row">
      <button class="btn" id="play">‚ñ∂Ô∏è Spielen</button>
      <button class="btn" id="reset">üßπ Reset</button>
    </div>
    <div class="sub" style="margin-top:10px;">
      Powerups: üõ°Ô∏è sch√ºtzt 1x ‚Ä¢ ‚è≥ wird kurz langsamer. Je l√§nger du lebst, desto schneller wird‚Äôs.
    </div>
  </div>
</div>

<script>
(() => {
  "use strict";
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d", { alpha:true, desynchronized:true });

  const $score = document.getElementById("score");
  const $best  = document.getElementById("best");
  const $coins = document.getElementById("coins");
  const $pause = document.getElementById("pause");

  const screen = document.getElementById("screen");
  const hint   = document.getElementById("hint");
  const mBest  = document.getElementById("mBest");
  const mCoins = document.getElementById("mCoins");
  const btnPlay = document.getElementById("play");
  const btnReset = document.getElementById("reset");

  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
  const rnd = (a,b)=>a+Math.random()*(b-a);

  const KEY="flip_dodge_v1";
  const data = (()=>{ try{return JSON.parse(localStorage.getItem(KEY)||"{}")}catch{return{}} })();
  let best = Number(data.best||0);
  let stars = Number(data.stars||0);

  let W=0,H=0,DPR=1;
  function resize(){
    DPR=Math.min(2.25, devicePixelRatio||1);
    W=innerWidth; H=innerHeight;
    canvas.width=Math.floor(W*DPR); canvas.height=Math.floor(H*DPR);
    ctx.setTransform(DPR,0,0,DPR,0,0);
  }
  addEventListener("resize", resize, {passive:true});
  resize();

  const S = {
    running:false, paused:false,
    score:0,
    speed:420,
    spawnT:0,
    laneX:[0,0],
    lane:0, // 0 left, 1 right
    shield:0,
    slow:0,
    obstacles:[],
    pickups:[],
    particles:[]
  };

  const P = { x:0,y:0,r:16, vx:0 };

  function save(){
    localStorage.setItem(KEY, JSON.stringify({best, stars}));
  }

  function hud(){
    $score.textContent = Math.floor(S.score);
    $best.textContent  = `Best: ${Math.floor(best)}`;
    $coins.textContent = Math.floor(stars);
    mBest.textContent  = Math.floor(best);
    mCoins.textContent = Math.floor(stars);
    $pause.textContent = S.paused ? "‚ñ∂Ô∏è" : "‚è∏Ô∏è";
  }

  function toastHint(){
    hint.classList.add("show");
    setTimeout(()=>hint.classList.remove("show"), 1200);
  }

  function resetRun(){
    S.score=0;
    S.speed=420;
    S.spawnT=0;
    S.lane=0;
    S.shield=0;
    S.slow=0;
    S.obstacles.length=0;
    S.pickups.length=0;
    S.particles.length=0;

    P.y = H*0.78;
    P.r = clamp(Math.min(W,H)*0.028, 12, 20);
    S.laneX[0]= W*0.30;
    S.laneX[1]= W*0.70;
    P.x = S.laneX[S.lane];
    P.vx = 0;
  }

  function start(){
    resetRun();
    S.running=true;
    S.paused=false;
    screen.style.display="none";
    toastHint();
    hud();
  }

  function gameOver(){
    S.running=false;
    S.paused=false;
    if (S.score > best) best = S.score;
    save();
    hud();
    screen.style.display="flex";
  }

  function flip(){
    if (!S.running){
      start();
      return;
    }
    if (S.paused) return;
    S.lane = 1 - S.lane;
    // quick snap feeling
    P.vx += (S.laneX[S.lane]-P.x) * 12;
    if (navigator.vibrate) navigator.vibrate(10);
  }

  // Touch / Click anywhere to flip
  addEventListener("pointerdown", (e) => {
    // ignore clicks on pause button
    if (e.target === $pause) return;
    flip();
  });

  $pause.addEventListener("click", () => {
    if (!S.running) return;
    S.paused = !S.paused;
    hud();
  });

  btnPlay.addEventListener("click", start);
  btnReset.addEventListener("click", () => {
    if (confirm("Reset Best & Stars?")){
      best=0; stars=0; save(); hud();
    }
  });

  // spawns
  function spawnObstacle(){
    const lane = Math.random()<0.5?0:1;
    const size = clamp(P.r*1.8 + rnd(-4, 8), P.r*1.5, P.r*2.3);
    S.obstacles.push({
      lane,
      x: S.laneX[lane],
      y: -40,
      r: size,
      kind: (Math.random()<0.22 ? "big" : "norm")
    });
  }
  function spawnPickup(){
    const lane = Math.random()<0.5?0:1;
    const kindRoll = Math.random();
    const kind = kindRoll < 0.72 ? "star" : (kindRoll < 0.86 ? "shield" : "slow");
    S.pickups.push({
      lane,
      x: S.laneX[lane],
      y: -40,
      r: P.r*0.9,
      kind,
      taken:false
    });
  }

  function circleHit(ax,ay,ar,bx,by,br){
    const dx=ax-bx, dy=ay-by;
    const rr=ar+br;
    return dx*dx+dy*dy <= rr*rr;
  }

  function burst(x,y,n=14){
    for(let i=0;i<n;i++){
      const a=Math.random()*Math.PI*2;
      const v=rnd(120,360);
      S.particles.push({x,y,vx:Math.cos(a)*v,vy:Math.sin(a)*v,t:0,life:rnd(0.35,0.75),r:rnd(1.5,3.2)});
    }
  }

  // main loop
  let last = performance.now();
  function loop(t){
    const dt = Math.min(0.033, (t-last)/1000);
    last=t;

    // draw bg + lanes
    ctx.clearRect(0,0,W,H);

    // subtle vignette
    const vg = ctx.createRadialGradient(W*0.5,H*0.45, 50, W*0.5,H*0.6, Math.max(W,H)*0.7);
    vg.addColorStop(0,"rgba(255,255,255,0.02)");
    vg.addColorStop(1,"rgba(0,0,0,0.25)");
    ctx.fillStyle=vg; ctx.fillRect(0,0,W,H);

    // lane lines
    ctx.globalAlpha=0.7;
    ctx.strokeStyle="rgba(255,255,255,0.10)";
    ctx.lineWidth=2;
    ctx.beginPath();
    ctx.moveTo(W*0.5, H*0.12); ctx.lineTo(W*0.5, H*0.92);
    ctx.stroke();
    ctx.globalAlpha=1;

    // update
    if (S.running && !S.paused){
      // difficulty
      S.speed += dt*18;
      S.score += dt*(22 + (S.speed-420)*0.03);
      if (S.score>best) best=S.score;

      // slow timer
      if (S.slow>0) S.slow = Math.max(0, S.slow - dt);

      const sp = S.speed * (S.slow>0 ? 0.68 : 1.0);

      // spawn rhythm
      S.spawnT -= dt;
      if (S.spawnT <= 0){
        S.spawnT = clamp(0.62 - (S.speed-420)*0.0006, 0.28, 0.62);
        spawnObstacle();
        if (Math.random() < 0.85) spawnPickup();
      }

      // player smooth move to lane x
      const tx = S.laneX[S.lane];
      P.vx = P.vx*0.82 + (tx - P.x)*18;
      P.x += P.vx * dt;
      P.x = clamp(P.x, 0, W);

      // obstacles move
      for (const o of S.obstacles){
        o.y += sp*dt;
        // collision
        if (circleHit(P.x,P.y,P.r*0.92, o.x,o.y,o.r)){
          if (S.shield>0){
            S.shield=0;
            burst(P.x,P.y,26);
            if (navigator.vibrate) navigator.vibrate(55);
          } else {
            burst(P.x,P.y,34);
            if (navigator.vibrate) navigator.vibrate(90);
            gameOver();
          }
        }
      }
      S.obstacles = S.obstacles.filter(o=>o.y < H+80);

      // pickups
      for (const p of S.pickups){
        if (p.taken) continue;
        p.y += sp*dt;
        if (circleHit(P.x,P.y,P.r*0.95, p.x,p.y,p.r)){
          p.taken=true;
          burst(p.x,p.y,16);
          if (navigator.vibrate) navigator.vibrate(16);
          if (p.kind==="star"){
            stars += 1;
            S.score += 10;
          } else if (p.kind==="shield"){
            S.shield = 1;
            S.score += 18;
          } else if (p.kind==="slow"){
            S.slow = 2.8;
            S.score += 18;
          }
          save();
        }
      }
      S.pickups = S.pickups.filter(p=>!p.taken && p.y < H+80);

      hud();
    }

    // draw obstacles
    for (const o of S.obstacles){
      ctx.save();
      ctx.shadowBlur=20;
      ctx.shadowColor = o.kind==="big" ? "rgba(255,90,122,.55)" : "rgba(255,210,124,.45)";
      const g = ctx.createLinearGradient(o.x-o.r,o.y-o.r,o.x+o.r,o.y+o.r);
      g.addColorStop(0, o.kind==="big" ? "rgba(255,90,122,.95)" : "rgba(255,210,124,.95)");
      g.addColorStop(1, "rgba(169,139,255,.75)");
      ctx.fillStyle=g;
      ctx.beginPath(); ctx.arc(o.x,o.y,o.r,0,Math.PI*2); ctx.fill();
      ctx.restore();
    }

    // draw pickups
    for (const p of S.pickups){
      if (p.taken) continue;
      ctx.save();
      ctx.shadowBlur=18;
      let c="rgba(255,210,124,.75)";
      let emoji="‚≠ê";
      if (p.kind==="shield"){ c="rgba(116,216,255,.75)"; emoji="üõ°Ô∏è"; }
      if (p.kind==="slow"){ c="rgba(124,255,178,.75)"; emoji="‚è≥"; }
      ctx.shadowColor=c;

      ctx.fillStyle=c;
      ctx.beginPath(); ctx.arc(p.x,p.y,p.r,0,Math.PI*2); ctx.fill();

      ctx.shadowBlur=0;
      ctx.font = `900 ${Math.floor(p.r*1.5)}px system-ui`;
      ctx.textAlign="center"; ctx.textBaseline="middle";
      ctx.fillStyle="rgba(10,12,20,.85)";
      ctx.fillText(emoji, p.x, p.y+0.5);
      ctx.restore();
    }

    // particles
    for (let i=S.particles.length-1;i>=0;i--){
      const p=S.particles[i];
      p.t += dt;
      const k=p.t/p.life;
      if (k>=1){ S.particles.splice(i,1); continue; }
      p.x += p.vx*dt; p.y += p.vy*dt;
      p.vx*=0.98; p.vy*=0.98;

      ctx.globalAlpha=(1-k)*0.85;
      ctx.fillStyle="rgba(255,255,255,.85)";
      ctx.beginPath(); ctx.arc(p.x,p.y,p.r*(1-k*0.3),0,Math.PI*2); ctx.fill();
      ctx.globalAlpha=1;
    }

    // player
    ctx.save();
    ctx.shadowBlur=28;
    ctx.shadowColor = S.shield ? "rgba(116,216,255,.75)" : "rgba(255,109,246,.55)";
    const pg = ctx.createLinearGradient(P.x-P.r,P.y-P.r,P.x+P.r,P.y+P.r);
    pg.addColorStop(0,"rgba(116,216,255,.95)");
    pg.addColorStop(1,"rgba(255,109,246,.92)");
    ctx.fillStyle=pg;
    ctx.beginPath(); ctx.arc(P.x,P.y,P.r,0,Math.PI*2); ctx.fill();

    // shield ring
    if (S.shield){
      ctx.shadowBlur=0;
      ctx.strokeStyle="rgba(116,216,255,.85)";
      ctx.lineWidth=3;
      ctx.beginPath(); ctx.arc(P.x,P.y,P.r*1.55,0,Math.PI*2); ctx.stroke();
    }
    // slow ring
    if (S.slow>0){
      ctx.strokeStyle="rgba(124,255,178,.65)";
      ctx.lineWidth=2;
      ctx.beginPath(); ctx.arc(P.x,P.y,P.r*1.9,0,Math.PI*2); ctx.stroke();
    }
    ctx.restore();

    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

  // init HUD + menu
  hud();
})();
</script>
</body>
</html>
